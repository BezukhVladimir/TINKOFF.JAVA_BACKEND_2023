# Backend-разработка на Java. Осень 2023

<img src="info.jpg" width="400">

Результаты отбора: <br>
https://t.me/tinkoff_fintech/1627

### Мой пост в группе курса за 2 октября 2023 года

Мне бы хотелось обсудить вступительные задания и поделиться обратной связью.

Я напишу про каждое задание теста и про каждое задание экзамена.

Мои заметки по каждому заданию публикую в отдельных сообщениях, чтобы на каждое из них можно было удобно ссылаться во время обсуждений.

Для выстраивания удобной хронологии сообщений прожимайте кнопку "ответить".

**Методистам:**<br>
Как и обещал в анкете, даю обратную связь по курсу. Мне интересно не только программирование, но и андрагогика, поэтому с удовольствием почитаю ваши ответы про логику составления заданий и в целом про особенности вашей работы.

### Тест, 1

    Пин-код для карты состоит из 4 цифр.

    Сколько существует пин-кодов, у которых все цифры разные или все цифры одинаковые? В качестве ответа напиши сумму.

**Моё решение:**<br>
Легко посчитать, что количество пин-кодов с одинаковыми цифрами, равно 10:
    
    0000
    1111
    ...
    9999

Далее комбинаторика. Для первой позиции можно выбрать любую из 10 цифр. Далее любую из 9 цифр... В итоге:
    
    10 * 9 * 8 * 7 = 5 040

Затем сложим все варианты:

    10 + 5 040 = 5 050

**Мой ответ:**<br>

    5 050

**Авторское решение:**<br>
    
    Количество пин-кодов, у которых все цифры разные: 10 * 9 * 8 * 7 = 5040
    
    Количество пин-кодов, у которых все цифры одинаковые: 10
    
    Итоговое количество пин-кодов является их суммой, т.е. 5050
    
    Авторский ответ:
    5 050

**Методистам:**<br>
В задаче говорится о том, что пин-код состоит из цифр. 0 — тоже цифра. Тем не менее, не помешает указать, что 0 входит в область определения пин-кода. Мелочь, а в условиях ограниченного времени на решение заданий, — приятно.

### Тест, 2

В отделе работает 5 Java-разработчиков и 7 фронтенд-разработчиков.

Сколько существует способов организовать команды из 2 Java и 3 фронтенд-разработчиков? Необходимо учесть факт, что 2 фронтенд-разработчика плохо работают вместе и их нужно распределить по разным командам.

**Методистам:**<br>
Обратите внимание на логику моего решения. На мой взгляд, этому заданию не хватает однозначности трактовки. «Организовать команды» можно понимать двояко: отдельно две команды Java и фронтенд-разработчиков, как делают авторы задачи, и команды как совокупности подгрупп разработчиков, как это делаю я. Тот, кто решает задачи, не должен угадывать логику их автора.

**Моё решение:**<br>
Моя цель сформировать команды из 2 Java и 3 фронтенд-разработчиков. Я понимаю это буквально. Начинаю с того, что считаю количество команд. Можно сформировать 2 команды (1 Java и 1 фронтенд-разработчик останутся без команды).

Соберём подгруппы Java-разработчиков. Первую подгруппу можно выбрать 10 способами. Затем из трёх оставшихся Java-разработчиков можно сформировать вторую подгруппу. Это можно сделать тремя способами. Всего получается 

    10 * 3 = 30

способов сформировать 2 подгруппы по 2 Java-разработчика.

Аналогично для фронтенд-разработчиков, но с учётом условия: два произвольно взятых фронтенд-разработчика из 7 нужно распределить по разным командам. Моё решение предполагает, что они могут:
* оказаться в разных командах;
* любой из них может оказаться без работы.

Сформировать первую подгруппу 3 фронтенд-разработчиков из 7 можно 35 способами. Среди этих способов можно выделить 4 развилки:
* в 5 способах из 35 два произвольно взятых фронтенд-разработчика окажутся вместе;
* в 10 способах из 35 первый произвольно взятый фронтенд-разработчик окажется в первой подгруппе;
* в 10 способах из 35 второй произвольно взятый фронтенд-разработчик окажется в первой подгруппе;
* в 10 способах из 35 два произвольно взятых фронтенд-разработчика не попадут в первую подгруппу.

Для формирования второй подгруппы фронтенд-разработчиков нам подходят 3 развилки (всего 30 вариантов). Далее, в зависимости от того, какая это развилка, получаем:
* если в первой подгруппе оказался один из двух произвольно взятых фронтенд-разработчиков, то получается 4 варианта сформировать вторую подгруппу;
* иначе получаем 2 варианта сформировать вторую подгруппу.

Итого способов сформировать 2 подгруппы фронтенд-разработчиков по 3 человека:

    20 * 4 + 10 * 2 = 100

Объединить получившиеся подгруппы Java и фронтенд-разработчиков можно 2 способами.

Всего способов:

    30 * 100 * 2 = 6 000

**Мой ответ:**<br>

    6 000

**Авторское решение:**<br>
    
    Количество способов выбрать 2 Java-разработчиков: С_5^2
    
    Количество способов выбрать 5 Frontend-разработчиков, причём 2 Frontend-разработчика плохо работают вместе и их нужно распределить по разным командам: C_7^3 - 5
    
    Количество способов составить команду: С_5^2 * (C_7^3 - 5) = 10 * (35 - 5) = 300
    
    Авторский ответ:
    300

### Тест, 3

    Определите временную сложность кода
    
    procedure f(int[] a, int[] b)
    begin
        N = a.length; M = b.length;
    
        for (i = 0; i < N; i++)
        for (j = 0; j < M; j++)
        if(a[i] < b[j]) println(a[i] + "," + b[j]);
    end

Моё и авторское решения:

    Два вложенных цикла

Мой и авторский ответы:

    O(NM)

### Тест, 4

Вы находитесь в случайном вагоне зацикленного поезда (последний вагон соединен с первым). В каждом вагоне случайным образом горит или не горит свет.

Вы можете совершать следующие действия:
- Перейти в следующий вагон
- Перейти в предыдущий вагон
- Узнать, горит ли в нынешнем вагоне свет
- Переключить свет в нынешнем вагоне

Придумайте такой алгоритм определения количества вагонов в поезде, чтобы в худшем случае он совершал минимальное количество действий среди других таких алгоритмов.

Какова алгоритмическая сложность такого алгоритма в нотации O-большое, если N - количество вагонов в поезде?

**Мои решение и ответ:**<br>

    N

На [этом математическом форуме](https://dxdy.ru/topic71733.html)
обсуждается эта задача с поездом и люди приводят решение за линию с константой.

**Авторские решение и ответ:**<br>
    
    O(N^2)
    Алгоритм выглядит следующим образом:
    
    - включаем свет в начальном вагоне и начинаем двигаться в строго одном направлении, при этом замеряя количество пройденных вагонов;
    - если встречаем вагон со светом, то выключаем и возвращаемся обратно и начинаем декрементировать счетчик;
    - как только мы получим ситуацию, что счетчик равен 0, то мы нашли длину.
    
    Мы бегаем из начального вагона по кольцу, как челнок, туда-сюда. Временная сложность такого алгоритма O(N^2).

**Методистам:**<br>
Есть подозрение, что эту задачу можно решить за линию.

**Комментарий авторов курса:**<br>
_Нам уже подсказали про решение за O(N), засчитали оба варианта при формировании списков_

### Тест, 5

Восемь разработчиков и руководитель пытаются выяснить кто виноват в падении сервера (логи утеряны). На вопрос руководителя "кто это сделал" были получены следующие ответы:

    Егор: "Уронил Андрей"
    Вика: "Андрей не ронял"
    Света: "Вика уронила"
    Оля: "Света уронила"
    Коля: "Это либо Вика, либо Света"
    Андрей: "Ни Вика, ни Света этого не делали"
    Надя: "Уронила Света"
    Миша: "Он сам упал"

Кто уронил сервер, если известно, что из возьми высказываний истинными являются только три?

**Мои решение и ответ:**<br>
Я составлял таблицы истинности, принимая по очереди утверждения "Уронил Андрей, уронила Вика, уронила Света" в качестве истины.

В итоге только вариант с Викой оказался подходящим по условию.

**Решение и ответ от username:**<br>
Мы обсуждали эту задачу с username. Он выбрал ответ "сам упал". Попробуем взять это утверждение в качестве истинного.
    
    Егор: "Уронил Андрей", ложь!
    Вика: "Андрей не ронял", правда!
    Света: "Вика уронила", ложь!
    Оля: "Света уронила", ложь!
    Коля: "Это либо Вика, либо Света", ложь!
    Андрей: "Ни Вика, ни Света этого не делали", правда!
    Надя: "Уронила Света", ложь!
    Миша: "Он сам упал", правда!

Получается тоже 3 истинных посылки.

**Авторские решение и ответ:**<br>

    Вика: "Андрей не ронял"
    Света: "Вика уронила"
    Коля: "Это либо Вика, либо Света"
    Ответ: Вика или вика

**Методистам:**<br>
Лично я не вижу изъянов в логике username. Но такой ответ никак не учитывается. Если по логике автора задачи, сервер не мог упасть самостоятельно, об этом нужно конкретно написать. Да, конечно, спрашивается "Кто" уронил сервер, но на мой взгляд это слишком незначительная деталь, поэтому задача выглядит слегка недоделанной.

### Тест, 6

В команде 7 человек: Аня, Иван, Гриша, Петя, Тагир, Володя и Федя.

Руководителю нужно решить в каком порядке они будут выступать с докладами на локальной конференции.

Известно, что:
- Гриша выступает перед Петей
- Федя выступает после Гриши, но необязательно сразу
- Между выступлениями Ани и Тагира ровно 2 других выступающих

Если Аня будет выступать второй, кто будет третьим выступающим?

**Моё решение:**<br>
_ А _ _ Т _ _ ← 3 и 4 посылка;<br>
1 посылка → Гриша, Петя → 2 человека подряд, Петя после Гриши → Гриша либо второй, либо шестой;<br>
2 посылка → Гриша, Петя, затем Федя → Гриша не может быть шестым.

**Мой ответ:**<br>

    Гриша

**Авторские решение и ответ:**<br>
Нужно визуализировать условие как таблицу из 7 ячеек и заполнить их согласно условию. Перебором приходим к выводу что третьим должен выступать Гриша

**Методистам:**<br>
Единственное, что заставило сомневаться, формулировка «Гриша выступает перед Петей». Решение задачи однозначно, только если после Гриши обязательно выступает Петя. Так почему бы об этом не указать явно, чтобы не могло возникнуть двоякого толкования? Да, дальше идёт посылка, в которой фигурирует «необязательно сразу», но, как по мне, нужно уточнить посылку.

### Тест, 7

Если бы Катя была Java-разработчиком и выпускницей крупного московского вуза, то она бы работала в Тинькофф.

Утверждение:

    Катя не Java-разработчик, поэтому она не работает в Тинькофф.

Утверждение выше некорректное, потому что мы не учли факт, что Катя могла бы:
- работать в Тинькофф Scala-разработчиком;
- быть аналитиком и выпускницей крупного московского вуза;
- быть Java-разработчиком из регионального вуза;
- быть разработчиком из Сбера;
- работать в Тинькофф в call-центре.

**Авторские решение и ответ:**<br>
Ответ: быть Java-разработчиком из регионального вуза

Это типовое условное утверждение if-then, по сути импликация P → Q.

Нужно применить отрицание, получить противопоставление и проверить получившийся список посылок.

**Мой комментарий:**<br>
Задание показалось громоздким. Мне не хватило времени его решить. Мне нечего добавить в обсуждение этой задачи.

### Тест, 8

Команда из 5 человек, все разных возрастов, сидит в офисе в один ряд. Какая будет вероятность того, что слева направо они сидят в порядке возрастания или убывания их возраста?

**Моё и авторское решения:**<br>
Всего вариантов рассадки 5!

Нас интересует 2 случая, тогда вероятность будет

2/5! = 2/120 = 1/60

**Мой и авторский ответы:**<br>

    1/60

### Тест, 9

У вас есть 2 монеты:
- стандартная, с вероятностью 1/2 для каждой из сторон
- специальная, с вероятностью выпадения решки 3/4

Вы взяли случайную монету и подбросили её 2 раза и два раза выпала решка.

Какая вероятность, что это была стандартная монета?

**Моё и авторское решения:**<br>
Решение через [формулу полной вероятности](https://tvims.nsu.ru/chernova/tv/lec/node14.html):

    P(A1 | B) = (P(B | A1) * P(A1)) / P(B)
    P(B) = P(B | A1) * P(A1) + P(B | A2) * P(A2)
    P(A1) = P(A2) = 1/2
    P(B | A1) = 1/4
    P(B | A2) = 9/16

    Подставим:
    1/4 * 1/2 + 9/16 * 1/2 = 4/13

**Мой и авторский ответы:**<br>

    4/13

### Тест, 10

SRE Иван едет из датацентра M1 в датацентр DS менять сетевое оборудование, скорость машины — 50км/ч.

С какой скоростью Иван должен ехать обратно, чтобы средняя скорость движения была 100км/ч?

**Методистам:**<br>
Строго говоря, в задаче находим среднюю путевую скорость. Найти среднюю скорость может иметь смысл, где скорость никак не связана со своими родителями — временем и расстоянием. Например, "средняя максимальная скорость автомобилей С класса".

**Моё и авторское решения:**<br>
    Формула скорости: V = S / T, тогда
    V_cp = 2*S / (T_1 + T_2)
    
    Выразим
    T_1 = S / 50
    T_2 = S / x
    
    Подставим
    V_cp = 2*S / (S/50 + S/x)
    V_cp = 2 / (1/50 + 1/x)
    
    Получается, что если V_cp = 100, то
    2 / (1/50 + 1/x) = 100, такое условие будет верным только тогда, когда x стремится к бесконечности

Мой и авторский ответы:

    +inf

### Экзамен, 1

Задача про обучение модели машинного обучения на серверах.

**Моё решение с комментариями (100/100):**
    
    // метод main
    try (Scanner scanner = new Scanner(System.in)) {
        // считывание
        int s = scanner.nextInt();
        int n = scanner.nextInt();
        
        // если единственный сервер, то все данные пройдут через него
        if (s == 1) {
            System.out.println(0);
            return;
        }
    
        // сумма арифметической прогрессии, общая мощность серверов
        int totalServerCapacity = (1 + s) * s / 2;
    
        // находим остаток данных после всех полных проходов по всем серверам
        int datasetCounter = n;
        datasetCounter %= totalServerCapacity;
        
        // прогоняем остатки данных по серверам, находим ответ (как можно улучшить эту часть решения?)
        if (datasetCounter != 0) {
        int currentServerCapacity = s;
        
            while (datasetCounter >= currentServerCapacity) {
              datasetCounter -= currentServerCapacity;
              --currentServerCapacity;
            }
        }
    
        System.out.print(datasetCounter);
    }

### Экзамен, 2

Особый метод шифрования паролей (как можно меньше символов в строке).

**Моё решение с комментариями (100/100):**
    
    // метод main
    try (Scanner scanner = new Scanner(System.in)) {
        // считывание
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        String s = scanner.next();
    
        // если количество символов в строке <= количество удалений,
        // то все символы будут удалены
        if (n <= k) {
            System.out.println(0);
            return;
        }
    
        // считаем количество символов
        Map<Character, Integer> charCount = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            charCount.compute(c, (key, value) -> (value == null) ? 1 : value + 1);
        }
    
        // сортируем счётчики по возрастанию
        List<Integer> counts = new ArrayList<>(charCount.values());
        Collections.sort(counts);
    
        // удаляем символы, начиная с самых редкоиспользуемых
        int removed = 0;
        int removals = k;
        for (int count : counts) {
            if (removals >= count) {
                removals -= count;
                ++removed;
            } else {
                break;
            }
        }
    
        // ответ
        int result = charCount.size() - removed;
        System.out.println(result);
    }

### Экзамен, 3

«Горки из ошибок». Промежутки возрастаний и убываний.

**Моё решение с комментариями (91/100):**
    
    static class Pair<A, B> {
        private final A first;
        private final B second;
        
        public Pair(A first, B second) {
            this.first  = first;
            this.second = second;
        }
        
        public A getFirst() {
            return first;
        }
        
        public B getSecond() {
            return second;
        }
    }
    
    // метод main
    try (Scanner scanner = new Scanner(System.in)) {
        // считывание
        int n = scanner.nextInt();
        int[] errorCounts = new int[n];
    
        for (int i = 0; i < n; ++i) {
            errorCounts[i] = scanner.nextInt();
        }
    
        int m = scanner.nextInt();
    
        // хранение благоприятных периодов
        List<Pair<Integer, Integer>> goodPeriod = new ArrayList<>();
        
        // отслеживаем перемены в сортировке чисел
        int left = 0;
        boolean isDecreasing = false;
        for (int i = 0; i < n - 1; ++i) {
            if (!isDecreasing && errorCounts[i] > errorCounts[i + 1]) {
                left = i;
                isDecreasing = true;
            } else if (isDecreasing && errorCounts[i] > errorCounts[i + 1]) {
                left = i;
            } else if (isDecreasing && errorCounts[i] < errorCounts[i + 1]) {
                goodPeriod.add(new Pair<>(left, i + 1));
                isDecreasing = false;
            }
        }
    
        // проверяем указанные периоды
        for (int i = 0; i < m; ++i) {
            int l = scanner.nextInt();
            int r = scanner.nextInt();
        
            boolean isFailure = true;
            for (Pair<Integer, Integer> pair : goodPeriod) {
              if (pair.getFirst() >= l - 1 && pair.getSecond() <= r - 1) {
                isFailure = false;
                break;
              }
            }
            
            if (isFailure) {
              System.out.println("Yes");
            } else {
              System.out.println("No");
            }
        }
    }

### Экзамен, 4

Задача, где нужно минимизировать произведение чисел.

**Моё решение с комментариями (94/100):**

    // чтобы не забыть исходную позицию
    static class Data {
        int startPosition;
        long value;
    
        public Data(int sp, long v) {
            this.startPosition = sp;
            this.value = v;
        }
    
        public boolean isPositive() {
            return (this.value >= 0);
        }
        
        public boolean isNegative() {
            return (this.value < 0);
        }
        
        public long getAbs() {
            return Math.abs(this.value);
        }
        
        public void increase(long d) {
            this.value += d;
        }
        
        public void decrease(long d) {
            this.value -= d;
        }
    }
    
    // метод main
    try (Scanner scanner = new Scanner(System.in)) {
        // считывание
        int n = scanner.nextInt();
        int c = scanner.nextInt();
        int d = scanner.nextInt();
        Data[] errorCounts = new Data[n];
        
        int minPositiveNumberId = 0;
        long minPositiveNumber = 1000000001;
            
        int negativeNumberCounter = 0;
            
        for (int i = 0; i < n; ++i) {
            errorCounts[i] = new Data(i, scanner.nextLong());
              
            if (errorCounts[i].isNegative()) {
                // считаем количество отрицательных чисел,
                // в нашем наборе множителей должно быть
                // нечётное количество таких чисел
                ++negativeNumberCounter;
            } else if (errorCounts[i].value < minPositiveNumber) {
                // находим минимальное положительное число
                minPositiveNumber = errorCounts[i].value;
                minPositiveNumberId = i;
            }
        }
            
        // если нам нужно сделать дополнительное отрицательное число
        if (negativeNumberCounter % 2 == 0) {
          
            // уменьшаем минимальное положительное, пока оно не станет отрицательным
            while (c > 0) {
                errorCounts[minPositiveNumberId].decrease(d);
                --c;
                
                if (errorCounts[minPositiveNumberId].isNegative()) {
                    break;
                }
            }
        }
        
        // создаю кучу с минимумом в корневом узле (значения по модулю)
        PriorityQueue<Data> minHeap = new PriorityQueue<>(new Comparator<Data>() {
            @Override
            public int compare(Data data1, Data data2) {
                return Long.compare(data1.getAbs(), data2.getAbs());
            }
        });
            
        // заполнение кучи множителями
        for (int i = 0; i < n; ++i) {
            minHeap.offer(errorCounts[i]);
        }
            
        // пока есть действия
        while (c > 0) {
            // берём текущий корневой узел (куча сама сортируется)
            Data minMultiplier = minHeap.poll();
        
            // если положительный, то увеличиваем
            if (minMultiplier.isPositive()) {
                minMultiplier.increase(d);
                --c;
            } else { // иначе уменьшаем
                minMultiplier.decrease(d);
                --c;
            }
        
            // меняем значения для вывода
            errorCounts[minMultiplier.startPosition].value = minMultiplier.value;
              
            // возвращаем множитель в кучу
            minHeap.offer(minMultiplier);
        }
        
        // вывод ответа в нужном порядке
        for (int i = 0; i < n; ++i) {
            System.out.print(errorCounts[i].value);
            if (i != n - 1) {
                System.out.print(' ');
            }
        }
    }

### Экзамен, 5

Задача про топологию сети серверов и рабочих мест.

**Моё текстовое описание решения (12/100):**<br>
Заметим, что топология сети такова, что для связи всех компьютеров со всеми серверами, все компьютеры должны быть соединены с одним центральным сервером. В этот сервер "стекаются" все остальные сервера.

1. Нахожу минимальное остовное дерево графа. Любой из этих серверов может быть центральным.
2. Количество связей = количество рёбер минимального остовного графа + количество связей из центрального сервера до компьютеров (оно равно количеству компьютеров).
3. Нахожу геометрическую медиану всех серверов. Сначала геометрический центр серверов, затем от него итерационно ищу подходящую точку.
4. Нахожу центральный сервер как ближайший сервер к геометрической медиане.
5. Считаю общую дистанцию (оставное дерево + связи центрального сервера с компьютерами).
6. Обхожу граф от центрального сервера для вывода соединений (все сервера "стекаются" в центральный)
7. Все компьютеры соединены с центральным сервером — вывожу от первого до последнего.


Моё решение может не проходить по времени. Или проверяющая система ожидает какой-то конкретный порядок вывода связей на серверах. Или в моём решении есть ошибки. Или есть ошибки в коде.

До этого я почти не пользовался языком Java и могу не знать какие-то его особенности. Всегда буду рад вашим советам.

**Методистам:**<br>
Я думаю, что это задание какое-то супер сложное для вступительного. Тем более на курс, а не на стажировку/работу.
